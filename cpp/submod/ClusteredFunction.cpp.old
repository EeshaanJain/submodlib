#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<cmath>
#include<set>
#include<iterator>
#include<map>
#include"ClusteredFunction.h"

ClusteredFunction::ClusteredFunction(ll n_, std::string function_name_, std::vector<std::set<ll>>clusters_, std::vector<std::vector<std::vector<float>>>clusterKernels_, std::vector<ll>clusterIndexMap_ )
{
    //TODO: there could be an alternate implementation of ClusteredFunction which takes ONE dense kernel and leverages partial = true for instantiating the components, each with the respective cluster as the ground subset

    n = n_;
    num_clusters = clusters_.size();
    function_name = function_name_;
    clusters = clusters_;
    clusterKernels = clusterKernels_;
    clusterIndexMap = clusterIndexMap_;
    clusterIDs.resize(n);
    clusters_translated.resize(num_clusters);

    for (ll i = 0; i < n; ++i) {
        effectiveGroundSet.insert(i); //each insert takes O(log(n)) time
    }

    for(int i=0;i<num_clusters;++i) { //O(n) (One time operation)
		std::set<ll>ci=clusters[i];
		for (auto it = ci.begin(); it != ci.end(); ++it) {
			ll ind = *it;
			clusterIDs[ind]=i;
            clusters_translated[i].insert(clusterIndexMap[ind]);//populating translated indicies
		}
	}

    for(int i=0;i<num_clusters;++i) {
        std::set<ll>ci = clusters_translated[i];//initilize function object with translated cluster system as that will be consistent with indicies in corresponding kernel
        std::vector<std::vector<float>>kernel = clusterKernels[i];
        SetFunction *f_obj;
        if(function_name=="FacilityLocation") {
            f_obj = new FacilityLocation;
        } else if(function_name == "DisparitySum") {
            f_obj = new DisparitySum;
        }
        f_obj->cluster_init(ci.size(), kernel, ci); 
        mixture.push_back(f_obj);
    }
}

std::set<ll> translate_X(std::set<ll>X, ClusteredFunction obj, ll cluster_id)//Before using X, its important to translate it to suitable form
{
    std::set<ll>X_res;
    //std::cout<<"C\n";
    for (auto it = X.begin(); it != X.end(); ++it) {
        ll ind = *it;
        if(obj.clusterIDs[ind]==cluster_id) { //if given data index is in current cluster then translate it to suitable index and put it in X_res
            X_res.insert(obj.clusterIndexMap[ind]);
        }
    }
    return X_res;
}

float ClusteredFunction::evaluate(std::set<ll> X) {
    float res=0;
    for(int i=0;i<num_clusters;++i) {
        std::set<ll>X_temp = translate_X(X, *this, i);
        res+=mixture[i]->evaluate(X_temp);
    }
    return res;
}

float ClusteredFunction::evaluateWithMemoization(std::set<ll> X) {
    float res=0;
    for(int i=0;i<num_clusters;++i) {
        std::set<ll>X_temp = translate_X(X, *this, i);
        res+=mixture[i]->evaluateWithMemoization(X);
    }
    return res;
}

float ClusteredFunction::marginalGain(std::set<ll> X, ll item) {
    ll i = clusterIDs[item];
    std::set<ll>X_temp = translate_X(X, *this, i);
    ll item_temp = clusterIndexMap[item];
    
    if(X_temp.size()==0) {
        float gain=0;
        std::set<ll>ci = clusters[i];

        for (auto it = ci.begin(); it != ci.end(); ++it) {
            ll ind = *it;
            ll ind_=clusterIndexMap[ind];
            ll item_ = clusterIndexMap[item];
            gain+=clusterKernels[i][ind_][item_];
        }
        return gain;
    }
    return mixture[i]->marginalGain(X_temp, item_temp);
}

float ClusteredFunction::marginalGainWithMemoization(std::set<ll> X, ll item) {
    ll i = clusterIDs[item];
    std::set<ll>X_temp = translate_X(X, *this, i);
    ll item_temp = clusterIndexMap[item];

    if(X_temp.size()==0) {
        float gain=0;
        std::set<ll>ci = clusters[i];

        for (auto it = ci.begin(); it != ci.end(); ++it)
        {
            ll ind = *it;
            ll ind_=clusterIndexMap[ind];
            ll item_ = clusterIndexMap[item];
            gain+=clusterKernels[i][ind_][item_];
        }
        return gain;
    }
    return mixture[i]->marginalGainWithMemoization(X_temp, item_temp);
}

void ClusteredFunction::updateMemoization(std::set<ll> X, ll item)
{
    ll i = clusterIDs[item];
    std::set<ll>X_temp = translate_X(X, *this, i);
    ll item_temp = clusterIndexMap[item];
    mixture[i]->updateMemoization(X_temp, item_temp);
}

std::set<ll> ClusteredFunction::getEffectiveGroundSet()
{
    return effectiveGroundSet;
}

std::vector<std::pair<ll, float>> ClusteredFunction::maximize(std::string s,float budget, bool stopIfZeroGain=false, bool stopIfNegativeGain=false, bool verbosity=false)
{
    //std::cout<<"A\n";
	if(s=="NaiveGreedy")
	{
		return NaiveGreedyOptimizer().maximize(*this, budget, stopIfZeroGain, stopIfNegativeGain, verbosity);
	} else {
        std::cerr << "Not yet implemented" << std::endl;
    }
}